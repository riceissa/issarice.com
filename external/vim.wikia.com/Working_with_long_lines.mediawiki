This page explains several strategies for dealing with long lines. Vim does not handle long lines well; there are restrictions to when a long line can partially be displayed and commands like <code>&lt;C-E&gt;</code> act on logical lines rather than visual lines. Part of the reason for this is that Vim is a descendant of [[Wikipedia:Line editor|line-based editors]] that only acted on logical lines. The upshot is that Vim will often feel "jumpy" when scrolling and moving in a buffer with long lines, especially ones that fill up the entire window.

You may encounter files with long lines in various situations:

* Conventions can require it; e.g. the English Wikipedia favors single-line paragraphs so lines tend to be long
* Some data files (JSON, CSVs, etc.) use long lines
* Content on the web is often presented in [[Wikipedia:Minification (programming)|minified]] form, leading to long lines

At a high level, the strategies for dealing with long lines can be grouped in the following way:

* Making use of Vim's built-in capabilities for navigating long lines (i.e. work around long lines without modifying them)
* Preprocessing the file to use shorter lines; the two strategies here are "chopping" and pretty-printing
* Taking steps to prevent long lines (rewriting code to use shorter lines, enforcing a manageable text width, etc.)
* Giving up on Vim for these files and using editors that work fine with long lines (gedit, GNU Emacs, etc.)

This article will cover the first two points.

==Navigating long lines with Vim's built-in capabilities==

Vim can attempt to show long lines with <code>:set wrap</code> (on by default). With <code>:set linebreak</code>, Vim will wrap the lines at characters in <code>'breakat'</code>; this generally makes the text easier to read. Also very useful is <code>:set display+=lastline</code>, which will try to show as much as possible of the last line in the window (rather than a column of "@", which is the default behavior).

The normal mode movements <code>j</code> and <code>k</code> move by logical lines, but these have the analogous <code>gj</code> and <code>gk</code> for moving by visual lines.

Search-to-navigate is another useful way to move. It's advisable to <code>:set incsearch</code> so that you can see the cursor move as you type, and then hit enter when you get to the desired location.

Note that the commands <code>f</code>, <code>t</code>, <code>F</code>, <code>T</code>, <code>;</code>, and <code>,</code> are even more powerful within long lines: they can cover more ground.

Using <code>:set scrolloff=99999</code> (or any large number instead of 99999) will keep the cursor in the middle of the screen, providing more context even in very long lines. This will allow you to type something like <code>5gj</code> to simulate <code>5&lt;C-E&gt;</code>.

==Preprocessing long lines==

===Generic formatting tools===

Most UNIX-like programming environments offer generic tools for formatting text. These include <code>fmt</code>, <code>fold</code>, and <code>par</code>. From inside Vim, one can invoke:

<pre>
:%!fmt -80 -s
</pre>

to format the current buffer. The <code>-80</code> specifies 80 columns as the desired width and the <code>-s</code> tells <code>fmt</code> to split lines only (i.e. to not join short lines together, called "refilling").

<code>fold</code> is more aggressive: it will chop lines even if there is no space.

In addition, Vim itself provides the command <code>gqq</code> to format the current line, so something like:

<pre>
:%normal! gqq
</pre>

will format the buffer according to the value of <code>'textwidth'</code>.

If the original linebreak locations must be preserved, you can leave a unique character in place of linebreaks. Below, the character '↵' (type using <code>&lt;C-V&gt;u21B5</code>) is provided as a suggestion, but it must not appear in the file itself.

<pre>
command! ShortLines :%s/.\{71}/&amp;↵\r/g | 1
command! ShortLinesAtSpace :%s/.\{70,79} /&amp;↵\r/g | 1
command! LongLines :%s/↵\n// | 1
</pre>

Note that this sort of regex replacement will be slow on large files.

===Filetype-specific tools===

Instead of generic tools, one can sometimes do better by using a tool suited to a particular filetype.

If you are working with JSON files and have Python installed (note: this is just the system binary rather than Python support being compiled into Vim):

<pre>
:%!python -m json.tool
</pre>

will convert the buffer into pretty-printed JSON. There are also plugins like [https://github.com/tpope/vim-jdaddy jdaddy.vim] that are designed to make work with JSON easier.

For HTML and XML, there are tools like <code>tidy</code> and <code>xmllint</code>; see [[Cleanup your HTML]] for the main article.

In some cases, <code>gg=G</code> might make things nicer.

Some plugins that try to unify this sort of pretty-printing/tidying are:

* [https://github.com/Chiel92/vim-autoformat vim-autoformat] (a lot of filetypes)
* [https://github.com/maksimr/vim-jsbeautify vim-jsbeautify] (JavaScript, HTML, CSS)

Languages like Go have strong source formatting requirements and provide tools like <code>gofmt</code>.

==See also==

* [[Word wrap without line breaks]]
* {{help|25.4}}, "Dealing with long lines", which has a couple of parts:
** {{help|edit-no-break}}
** {{help|edit-paragraph-join}}

==References==

* [https://github.com/neovim/neovim/issues/4232 How can Neovim implement scrolling based on screen-lines in long strings of wrapped text?] – an issue filed in the Neovim development issues tracker; this might be the only real shot at getting better long lines support in Vim/Neovim.
* [http://doc.cat-v.org/bell_labs/structural_regexps/se.pdf "Structural Regular Expressions"], an essay by Rob Pike on breaking out of the idea of line-based regular expressions.
